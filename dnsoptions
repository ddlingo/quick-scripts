You‚Äôre in a good spot now that other folks are engaged.
Here‚Äôs how I‚Äôd look at what they‚Äôre proposing and how you can respond.

---

## 1. Are there better / different solutions than what they suggest?

What they‚Äôre saying in the comment:

* Use **`Get-DnsClientGlobalSetting -SuffixSearchList @("$param")`** (they almost certainly meant `Set-DnsClientGlobalSetting`) in the **domain-join script** so the suffix is correct at join time.
* Use a **GPO** as the second layer to enforce it long-term.

That‚Äôs basically the same architecture we‚Äôve been circling around:

1. **Fix DNS before / during join**
2. **Enforce DNS after join via GPO**

So conceptually: ‚úÖ

A couple of technical refinements you can (gently) add:

1. **Cmdlet name** ‚Äì to *set* the suffix list you need:

   ```powershell
   Set-DnsClientGlobalSetting -SuffixSearchList @("$param")
   ```

   `Get-‚Ä¶` just reads the value.

2. **We still need to fix the DNS servers as well**, not just the suffix list.
   If the image‚Äôs DNS servers still point to SAP/cloud DNS instead of AD DNS, join will keep failing even with a good suffix:

   ```powershell
   Get-DnsClientAdapter | ForEach-Object {
       Set-DnsClientServerAddress -InterfaceIndex $_.InterfaceIndex `
         -ServerAddresses $AdDnsServers
   }
   ```

3. **The bad image-level SearchList in `Tcpip\Parameters` should be cleared** once, so it doesn‚Äôt fight the new setting:

   ```powershell
   Remove-ItemProperty `
     -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
     -Name 'SearchList' -ErrorAction SilentlyContinue
   ```

4. Your original Ansible idea is still valuable as a **3rd layer**:

   * For **post-join drift correction** (outside GPO scope, lab tenants, etc).
   * For **visibility / reporting** (‚Äúshow me which SCI VMs don‚Äôt have the right DNS‚Äù).

So: their approach isn‚Äôt ‚Äúworse‚Äù ‚Äì it‚Äôs actually a reasonable core.
The best version is:

* **Domain-join script:**
  Set DNS servers + `Set-DnsClientGlobalSetting -SuffixSearchList` + clear the bad legacy SearchList.
* **GPO:**
  Enforce suffix search list long-term.
* **(Optional) Ansible:**
  Audit & remediate across all SCI tenants / environments where GPO doesn‚Äôt reach.

---

## 2. A concise reply you can drop into Jira / Slack

Here‚Äôs something you can paste with minimal edits:

> Thanks, this lines up with what I was seeing on the VMs.
>
> From the SCI Windows image we‚Äôve confirmed two issues:
>
> * DNS servers are pointing at the SAP/cloud resolvers instead of AD DNS.
> * `HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\SearchList` is populated with `global.cloud.sap, mo.sap.corp, ‚Ä¶` which breaks DC discovery.
>
> I‚Äôm aligned with the plan to fix this in two layers:
>
> 1. **Domain-join script:**
>
>    * Set the NIC DNS servers to the AD DNS IPs.
>    * Set the suffix search list with something like:
>
>      ```powershell
>      Set-DnsClientGlobalSetting -SuffixSearchList @("$param")
>      ```
>
>      where `$param` is the AD DNS domain.
>    * Optionally clear the old image value once:
>
>      ```powershell
>      Remove-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' -Name 'SearchList' -ErrorAction SilentlyContinue
>      ```
> 2. **GPO:**
>
>    * Enforce the DNS suffix search list and devolution settings long-term on all joined servers.
>
> I originally prototyped this with Ansible + PowerShell from the VM side; we can still use Ansible later as an additional audit/remediation layer (for tenants or servers that aren‚Äôt under this GPO), but I‚Äôm fine with the domain-join script + GPO being the authoritative path as long as we include both the DNS server change and the suffix change.

If you want it shorter, you can trim out the code blocks and just keep the bullets.

---

============================================================


I'd like to see althe Ansible play... I do not have winrm working on the vms....Also how difficult would it be to open the image, make th needed changes and then save it as a new image?  

============================================================
Good questions ‚Äì let‚Äôs separate them:

---

## 1) Ansible play that mirrors the PowerShell automation

You can keep this parked for **‚Äúlater, when WinRM works‚Äù**. It does the same things we‚Äôve been doing manually:

* Set AD DNS servers
* Clear the bad image SearchList
* Set the correct DNS suffix
* Disable devolution

### Example inventory (once WinRM is enabled)

```ini
[windows]
sapwin01 ansible_host=10.10.0.25

[windows:vars]
ansible_user=Administrator
ansible_password=SuperSecret!
ansible_connection=winrm
ansible_winrm_transport=ntlm
ansible_winrm_scheme=https
ansible_winrm_server_cert_validation=ignore
ansible_port=5986
```

### `fix_dns_suffix.yml`

```yaml
- name: Fix DNS servers and suffix search list on SCI Windows VMs
  hosts: windows
  gather_facts: no

  vars:
    # EDIT THESE FOR YOUR ENV:
    ad_dns_servers:
      - 10.20.30.40
      - 10.20.30.41
    ad_dns_domain: "directory.sci-dev.scs.internal"

  tasks:
    - name: Set AD DNS servers on all adapters
      ansible.windows.win_dns_client:
        adapter_names: '*'
        ipv4_addresses: "{{ ad_dns_servers }}"

    - name: Clear legacy SearchList in Tcpip Parameters
      ansible.windows.win_regedit:
        path: HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters
        name: SearchList
        state: absent

    - name: Set global DNS suffix search list (Policies\DNSClient)
      ansible.windows.win_regedit:
        path: HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient
        name: SearchList
        type: string
        data: "{{ ad_dns_domain }}"

    - name: Disable DNS devolution via policy
      ansible.windows.win_regedit:
        path: HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient
        name: UseDomainNameDevolution
        type: dword
        data: 0

    # Optional: verify effective value (this just echoes it in the log)
    - name: Show effective SearchList
      ansible.windows.win_shell: |
        reg query HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters /v SearchList
      register: reg_query

    - debug:
        var: reg_query.stdout_lines
```

Run (once WinRM works):

```bash
ansible-playbook -i inventory.ini fix_dns_suffix.yml
```

That play aligns with what your teammates are doing via PowerShell/GPO, and gives you an automation hook when you *do* have WinRM.

---

## 2) ‚ÄúHow hard is it to open the image, change it, and save as a new image?‚Äù

**Technically:** not that hard for someone with your background.
**Process-wise:** usually the hard part is *governance / ownership*, not the mechanics.

### Typical technical flow for a Windows image on (SAP) OpenStack

1. **Start from the existing image**

   * In SCI/OpenStack:
     launch a **temporary VM** from the current Windows image (the one with the bad SearchList).

2. **Log into the temp VM and make your changes**

   * Fix *exactly* what you want baked in:

     * Clear `Tcpip\Parameters\SearchList`
     * Set `Set-DnsClientGlobalSetting -SuffixSearchList @('<your-domain>')` (or leave suffix blank and let DHCP/GPO handle it)
     * Optionally enable WinRM HTTPS and install any base tools your org expects
   * Clean up:

     * Clear event logs / temp files
     * Make sure no secrets, no AD join, no machine-specific config.

3. **Generalize the VM (Windows sysprep)**

   * Run something like:

     ```powershell
     sysprep.exe /generalize /oobe /shutdown /unattend:C:\path\to\unattend.xml
     ```
   * Once sysprep finishes, the VM powers off.

4. **Create a new image from that VM**

   * In OpenStack/SCI: create an **image from the volume / instance** (Glance).
   * Give it a new name like:
     `win-2019-sci-adready-v2`
   * Mark it as the new ‚Äúblessed‚Äù image (whatever process SCI uses).

5. **Test**

   * Boot a fresh VM from the new image.
   * Check:

     * DNS servers (if you baked them in, or that they‚Äôre still DHCP/neutral)
     * SearchList is either empty or correct
     * Domain join works without manual tweaks.

### Pros of fixing the image

* Every future VM comes up **right** ‚Äì no need for bootstrap hacks.
* You reduce drift and weird edge cases.
* It simplifies your domain-join logic (less ‚Äúband-aid‚Äù scripting).

### Cons / friction points

* Image pipeline is ‚Äúowned‚Äù by another team (which you already mentioned).
* They may have:

  * Change-control / CAB requirements
  * Golden image hardening standards
  * Security sign-offs
* If SCI is multi-tenant, they might not want AD-specific assumptions (like baking in your suffix).

That‚Äôs exactly why your current plan (fix at runtime + GPO enforcement) is attractive: **you don‚Äôt need to own the image**, just the automation around it.

---

### My honest take

* **Best long-term**:
  Fix the image **+** GPO enforcement (cleanest future state).
* **Best ‚Äúpolitically feasible‚Äù right now**:

  * Keep your Cloudbase-Init / domain-join PowerShell +
  * Add the GPO they‚Äôre talking about +
  * Keep an Ansible play like the one above ready for:

    * Cross-tenant remediation
    * Audits
    * ‚ÄúFix everything that slipped through‚Äù

So if someone asks, ‚ÄúCouldn‚Äôt we just fix the image?‚Äù you can calmly say:

> Yes, technically it‚Äôs straightforward: boot from the image, correct DNS/ suffix, sysprep, snapshot a new Glance image, and bless it as the new SCI Windows base.
> Right now, because image ownership sits with <team>, we‚Äôre solving it at runtime via the domain-join script + GPO, and we have an Ansible play ready for broad enforcement once WinRM is available.

============================================================
Below is **exactly what you asked for** ‚Äî clean, direct, technical steps for:

1. **Rebuilding a corrected Windows image on SAP SCI/OpenStack**
2. **Enabling WinRM (HTTPS) on that image or any running VM**

No fluff. Everything is structured so you could hand it to another engineer or team.

---

# ‚úÖ **PART 1 ‚Äî How to Fix the SAP SCI Windows Image (Step-by-Step)**

This is the *precise, minimal* process to take the existing bad SCI Windows image, correct it, sysprep it, and save it as a new ‚Äúgolden‚Äù image.

This is standard OpenStack workflow with Windows sysprep.

---

## **‚òëÔ∏è Step 0 ‚Äî Requirements**

You need:

* **SCI/OpenStack dashboard access** or CLI
* Ability to:

  * Launch a VM from the image
  * Create an image from a shutdown VM
  * Assign a floating IP or console access
* **Local Administrator** access to Windows
* Optional: Permission to upload the new image to the ‚Äúblessed image‚Äù catalog

---

# **‚òëÔ∏è Step 1 ‚Äî Launch a Temp VM From the Current Image**

Name it something like:

```
win2019-imagefix-temp
```

Assign any flavor, doesn‚Äôt matter (2 CPU / 4 GB RAM minimum).

Attach a floating IP.

RDP into it.

---

# **‚òëÔ∏è Step 2 ‚Äî Fix the DNS Issues in the Image**

### Clear the broken baked-in SearchList

```powershell
Remove-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'SearchList' `
  -ErrorAction SilentlyContinue
```

### Optionally ‚Äî set a **neutral** SearchList (recommended)

Do NOT hardcode your domain into the golden image unless all consumers share the same AD environment.

The safest approach is to **leave SearchList empty** and let:

* Cloudbase-Init
* Domain-Join script
* GPO
  apply the correct values.

So:
‚úî **Do NOT set any SearchList in the image**
‚úî Just remove the SAP garbage values

### Disable devolution (safer default)

```powershell
Set-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'UseDomainNameDevolution' `
  -Type DWord `
  -Value 0
```

### DO NOT set DNS servers

DNS servers should come from DHCP, Cloudbase-Init, or your domain-join script.

---

# **‚òëÔ∏è Step 3 ‚Äî (Optional but Recommended) Enable WinRM HTTPS in the Image**

This gives you Ansible management ‚Äúout of the box.‚Äù

```powershell
# Create self-signed cert
$cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME `
   -CertStoreLocation Cert:\LocalMachine\My

# Clean old listeners
winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null

# Create new listener
winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
   "@{Hostname=`"$env:COMPUTERNAME`"; CertificateThumbprint=`"$($cert.Thumbprint)`"}"

# Harden
winrm set winrm/config/service '@{AllowUnencrypted="false"}'
winrm set winrm/config/service/Auth '@{Basic="true"; Kerberos="true"; Negotiate="true"}'

# Open firewall
If (-not (Get-NetFirewallRule -DisplayName "WINRM-HTTPS-In" -ErrorAction SilentlyContinue)) {
  New-NetFirewallRule -DisplayName "WINRM-HTTPS-In" -Direction Inbound -Protocol TCP -LocalPort 5986 -Action Allow
}
```

Be aware:

* You MUST NOT join this ‚Äúgolden image fix VM‚Äù to the domain.
* WinRM will be re-keyed after sysprep ‚Äî this is correct.

---

# **‚òëÔ∏è Step 4 ‚Äî Generalize the Image With Sysprep**

Create a simple `unattend.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend">
  <settings pass="oobeSystem">
    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64"
               publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <OOBE>
        <HideEULAPage>true</HideEULAPage>
        <NetworkLocation>Work</NetworkLocation>
        <ProtectYourPC>3</ProtectYourPC>
      </OOBE>
    </component>
  </settings>
</unattend>
```

Save it as:

```
C:\unattend.xml
```

Run:

```powershell
sysprep.exe /generalize /oobe /shutdown /unattend:C:\unattend.xml
```

**Wait for sysprep to fully shut down the VM.**

---

# **‚òëÔ∏è Step 5 ‚Äî Create a New Image (OpenStack)**

In the SCI OpenStack dashboard:

1. Go to **Compute ‚Üí Instances**
2. Select the temp VM (now SHUTOFF)
3. Choose **Create Image**
4. Provide:

   * Name: `windows-2019-fixed-v1`
   * Disk Format: `qcow2` or as required
   * Visibility: private (unless publishing)

Click **Create Image**.

You now have a corrected image.

---

# **‚òëÔ∏è Step 6 ‚Äî Test the New Image**

Launch a fresh VM:

* Check DNS servers (DHCP-provided or cloud-init set)
* Verify SearchList is **empty**
* Test:

  ```powershell
  nslookup yourdomain.com
  ```
* Test:

  ```powershell
  Add-Computer -DomainName "yourdomain" -Credential (Get-Credential)
  ```

If it joins cleanly ‚Üí success.

---

# ‚úÖ **PART 2 ‚Äî What‚Äôs Needed to Enable WinRM (for Ansible)**

WinRM can be enabled **either in the image** or **on a per-VM basis**.

### Minimum needed:

1. **PSRemoting enabled**

```powershell
Enable-PSRemoting -Force
```

2. **HTTPS listener on port 5986**

```powershell
winrm create winrm/config/Listener?Address=*+Transport=HTTPS
```

(Requires a certificate ‚Äî a self-signed is fine.)

3. **Firewall rule**

```powershell
New-NetFirewallRule -DisplayName "WINRM-HTTPS-In" -Protocol TCP -LocalPort 5986 -Action Allow
```

4. **Authentication**

```powershell
winrm set winrm/config/service/Auth '@{Basic="true";Kerberos="true";Negotiate="true"}'
```

5. **Disable unencrypted**

```powershell
winrm set winrm/config/service '@{AllowUnencrypted="false"}'
```

---

# ‚≠ê Final Recommendation

### Best long-term state:

1. **Fix the golden image**
   ‚Üí Every deployment starts correct
2. **Domain-join script sets AD DNS + suffix**
3. **GPO enforces suffix after join**
4. **WinRM baked into image**
   ‚Üí Easy automation across all SCI VM fleets
5. **Ansible role** for audits + remediation

This gives you **zero-touch deployment + consistent post-join control**.

---

If you'd like, I can generate:

* A **Cloudbase-Init version** of the image fixes
* A **Windows sysprep script** you can hand to the image team
* An **OpenStack CLI version** of the image build steps
* A **one-click master script** that enables WinRM and fixes DNS automatically on first boot



============================================================

Nice, let‚Äôs turn this into something you can actually hand to people and/or drop straight into SCI.

I‚Äôll give you **four things**:

1. Cloudbase-Init snippets (ps1 + cloud-config)
2. A **sysprep prep script** for the image team
3. **OpenStack CLI** steps to build the new image
4. A **one-click ‚Äúmaster‚Äù bootstrap script** that fixes DNS + enables WinRM on first boot

I‚Äôll use placeholders you can swap (`$AdDnsServers`, `$AdDnsDomain` etc.).

---

## 1Ô∏è‚É£ Cloudbase-Init snippets

### 1a) Simple `#ps1` user-data (runs once on first boot)

Use this when you deploy a VM from the (possibly still-bad) image:

```powershell
#ps1
# --------- CONFIGURE THESE VALUES ----------
$AdDnsDomain  = 'directory.sci-dev.scs.internal'
$AdDnsServers = @('10.20.30.40','10.20.30.41')  # AD DNS IPs
$EnableWinRM  = $true
# ------------------------------------------

# Clear legacy global SearchList baked into image
Remove-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'SearchList' `
  -ErrorAction SilentlyContinue

# Optionally set a clean SearchList (or comment this out if you want GPO only)
Set-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'SearchList' `
  -Value $AdDnsDomain

# Disable DNS devolution
Set-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'UseDomainNameDevolution' `
  -Type DWord `
  -Value 0

# Set AD DNS servers on all active adapters
Get-DnsClientAdapter | ForEach-Object {
    Set-DnsClientServerAddress -InterfaceIndex $_.InterfaceIndex `
      -ServerAddresses $AdDnsServers
}

if ($EnableWinRM) {
    # Create a self-signed cert and WinRM HTTPS listener
    $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME `
      -CertStoreLocation Cert:\LocalMachine\My

    winrm quickconfig -quiet
    winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null

    winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
      "@{Hostname=`"$env:COMPUTERNAME`";CertificateThumbprint=`"$($cert.Thumbprint)`"}"

    winrm set winrm/config/service '@{AllowUnencrypted="false"}'
    winrm set winrm/config/service/Auth '@{Basic="true";Kerberos="true";Negotiate="true"}'

    # Open firewall for 5986
    if (-not (Get-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' -ErrorAction SilentlyContinue)) {
        New-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' `
          -Direction Inbound -Protocol TCP -LocalPort 5986 -Action Allow
    }
}
```

---

### 1b) `#cloud-config` style that writes + runs a script

```yaml
#cloud-config
write_files:
  - path: C:\ProgramData\Cloudbase Solutions\Scripts\bootstrap-dns-winrm.ps1
    content: |
      $AdDnsDomain  = 'directory.sci-dev.scs.internal'
      $AdDnsServers = @('10.20.30.40','10.20.30.41')
      $EnableWinRM  = $true

      Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
        -Name 'SearchList' -ErrorAction SilentlyContinue

      Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
        -Name 'SearchList' -Value $AdDnsDomain

      Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
        -Name 'UseDomainNameDevolution' -Type DWord -Value 0

      Get-DnsClientAdapter | ForEach-Object {
          Set-DnsClientServerAddress -InterfaceIndex $_.InterfaceIndex `
            -ServerAddresses $AdDnsServers
      }

      if ($EnableWinRM) {
        $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME `
          -CertStoreLocation Cert:\LocalMachine\My

        winrm quickconfig -quiet
        winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null
        winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
          "@{Hostname=`"$env:COMPUTERNAME`";CertificateThumbprint=`"$($cert.Thumbprint)`"}"
        winrm set winrm/config/service '@{AllowUnencrypted="false"}'
        winrm set winrm/config/service/Auth '@{Basic="true";Kerberos="true";Negotiate="true"}'
        if (-not (Get-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' -ErrorAction SilentlyContinue)) {
          New-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' -Direction Inbound `
            -Protocol TCP -LocalPort 5986 -Action Allow
        }
      }

powershell:
  - "C:\\ProgramData\\Cloudbase Solutions\\Scripts\\bootstrap-dns-winrm.ps1"
```

---

## 2Ô∏è‚É£ Sysprep prep script for the image team

This is what you can hand your image folks as ‚Äúdo this inside the temp VM before taking the image.‚Äù

### `prepare-golden-image.ps1`

```powershell
# prepare-golden-image.ps1
# Run as local Administrator on the temp VM built from the old image.

Write-Host "Clearing baked-in DNS SearchList..." -ForegroundColor Cyan
Remove-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'SearchList' -ErrorAction SilentlyContinue

Write-Host "Disabling DNS devolution..." -ForegroundColor Cyan
Set-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'UseDomainNameDevolution' `
  -Type DWord -Value 0

# OPTIONAL: enable WinRM HTTPS in the image (comment out if they don't want this baked in)
$EnableWinRMInImage = $true
if ($EnableWinRMInImage) {
    Write-Host "Enabling WinRM HTTPS..." -ForegroundColor Cyan
    $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME `
      -CertStoreLocation Cert:\LocalMachine\My

    winrm quickconfig -quiet
    winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null

    winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
      "@{Hostname=`"$env:COMPUTERNAME`";CertificateThumbprint=`"$($cert.Thumbprint)`"}"

    winrm set winrm/config/service '@{AllowUnencrypted="false"}'
    winrm set winrm/config/service/Auth '@{Basic="true";Kerberos="true";Negotiate="true"}'

    if (-not (Get-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' -ErrorAction SilentlyContinue)) {
        New-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' `
          -Direction Inbound -Protocol TCP -LocalPort 5986 -Action Allow
    }
}

# Create a minimal unattend.xml for sysprep
$unattend = @"
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend">
  <settings pass="oobeSystem">
    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64"
               publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <OOBE>
        <HideEULAPage>true</HideEULAPage>
        <NetworkLocation>Work</NetworkLocation>
        <ProtectYourPC>3</ProtectYourPC>
      </OOBE>
    </component>
  </settings>
</unattend>
"@

$unattendPath = "C:\unattend.xml"
Write-Host "Writing unattend.xml to $unattendPath" -ForegroundColor Cyan
$unattend | Out-File -FilePath $unattendPath -Encoding utf8 -Force

Write-Host "Running sysprep /generalize /oobe /shutdown..." -ForegroundColor Yellow
& "$env:SystemRoot\System32\Sysprep\Sysprep.exe" /generalize /oobe /shutdown /unattend:$unattendPath
```

**Usage for image team:**

1. Boot temp VM from existing image.
2. RDP in as local admin.
3. Run this script.
4. VM will **shut down** when sysprep finishes.
5. Use that VM to create the new image.

---

## 3Ô∏è‚É£ OpenStack CLI steps (SCI-style) to create the new image

Assuming standard `openstack` CLI is available.

### 3a) Launch temp VM from old image

```bash
# Variables
OLD_IMAGE="win-2019-sap-bad"
FLAVOR="m1.medium"
NET_ID="<network-id>"
KEY_NAME="your-keypair"
NAME="win2019-imagefix-temp"

openstack server create \
  --image "$OLD_IMAGE" \
  --flavor "$FLAVOR" \
  --nic net-id="$NET_ID" \
  --key-name "$KEY_NAME" \
  "$NAME"
```

Allocate + associate a floating IP (if needed):

```bash
FLOAT_NET="public"
FIP=$(openstack floating ip create -f value -c floating_ip_address "$FLOAT_NET")
openstack server add floating ip "$NAME" "$FIP"
echo "RDP to: $FIP"
```

Then: run `prepare-golden-image.ps1` inside the VM and wait for it to shut down.

---

### 3b) Create the new image from that sysprepped VM

Once the VM is in `SHUTOFF` state:

```bash
NEW_IMAGE="win-2019-fixed-v1"

openstack server image create \
  --name "$NEW_IMAGE" \
  "$NAME"
```

Or, if your SCI setup wants volume-backed:

```bash
# find root volume
VOL_ID=$(openstack server show -f value -c volumes_attached "$NAME" | sed 's/[^:]*://')
openstack image create --name "$NEW_IMAGE" --volume "$VOL_ID"
```

You can add properties if needed:

```bash
openstack image set \
  --property os_type=windows \
  --property hw_disk_bus=scsi \
  "$NEW_IMAGE"
```

Then test:

```bash
openstack server create \
  --image "$NEW_IMAGE" \
  --flavor "$FLAVOR" \
  --nic net-id="$NET_ID" \
  --key-name "$KEY_NAME" \
  win2019-fixed-test
```

---

## 4Ô∏è‚É£ One-click ‚Äúmaster‚Äù bootstrap script (DNS + WinRM on first boot)

This is something you can call from **Cloudbase-Init**, Ansible, or just run once manually. It combines:

* DNS servers
* DNS suffix + devolution
* WinRM HTTPS listener + firewall

### `bootstrap-dns-winrm.ps1`

```powershell
param(
    [string]   $AdDnsDomain  = "directory.sci-dev.scs.internal",
    [string[]] $AdDnsServers = @("10.20.30.40","10.20.30.41"),
    [bool]     $EnableWinRM  = $true
)

Write-Host "Setting AD DNS servers: $($AdDnsServers -join ', ')" -ForegroundColor Cyan
Get-DnsClientAdapter | ForEach-Object {
    Set-DnsClientServerAddress -InterfaceIndex $_.InterfaceIndex `
        -ServerAddresses $AdDnsServers
}

Write-Host "Clearing legacy global SearchList..." -ForegroundColor Cyan
Remove-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'SearchList' -ErrorAction SilentlyContinue

Write-Host "Setting SearchList to $AdDnsDomain..." -ForegroundColor Cyan
Set-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'SearchList' `
  -Value $AdDnsDomain

Write-Host "Disabling DNS devolution..." -ForegroundColor Cyan
Set-ItemProperty `
  -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters' `
  -Name 'UseDomainNameDevolution' `
  -Type DWord `
  -Value 0

if ($EnableWinRM) {
    Write-Host "Configuring WinRM HTTPS..." -ForegroundColor Cyan
    $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME `
      -CertStoreLocation Cert:\LocalMachine\My

    winrm quickconfig -quiet
    winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null

    winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
      "@{Hostname=`"$env:COMPUTERNAME`";CertificateThumbprint=`"$($cert.Thumbprint)`"}"

    winrm set winrm/config/service '@{AllowUnencrypted="false"}'
    winrm set winrm/config/service/Auth '@{Basic="true";Kerberos="true";Negotiate="true"}'

    if (-not (Get-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' -ErrorAction SilentlyContinue)) {
        New-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' `
          -Direction Inbound -Protocol TCP -LocalPort 5986 -Action Allow
    }
}

Write-Host "Current DNS configuration:" -ForegroundColor Yellow
Get-DnsClientServerAddress | Format-Table -AutoSize

Write-Host "SearchList value:"
reg query HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters /v SearchList
```

Example manual usage on a VM:

```powershell
.\bootstrap-dns-winrm.ps1 `
  -AdDnsDomain "directory.sci-dev.scs.internal" `
  -AdDnsServers @("10.20.30.40","10.20.30.41") `
  -EnableWinRM $true
```

---

If you want to next-step this, we can:

* Wrap the **domain join** itself into a similar script (with `Add-Computer` + reboot), and
* Then mirror that logic in a tiny Ansible role for when WinRM is available.


  

 ============================================================
Nice, this is where everything you‚Äôve been doing manually starts to pay off üí™

Below is:

1. An **Ansible role** that does the same work as your PowerShell bootstrap (DNS + suffix + WinRM)
2. A tiny **playbook** that uses it
3. A clear list of **benefits** of having this as a role vs one-off scripts

---

## 1Ô∏è‚É£ Role layout

Let‚Äôs call the role: `sci_windows_dns_winrm`

```text
roles/
  sci_windows_dns_winrm/
    defaults/
      main.yml
    tasks/
      main.yml
```

---

## 2Ô∏è‚É£ `defaults/main.yml`

These are your tunables. You can override them per-env or per-tenant.

```yaml
# roles/sci_windows_dns_winrm/defaults/main.yml

sci_ad_dns_domain: "directory.sci-dev.scs.internal"

# AD DNS servers you want Windows to use
sci_ad_dns_servers:
  - "10.20.30.40"
  - "10.20.30.41"

# Whether to configure WinRM HTTPS listener + firewall
sci_enable_winrm: true
```

---

## 3Ô∏è‚É£ `tasks/main.yml`

This mirrors the bootstrap PowerShell you‚Äôve been running by hand.

```yaml
# roles/sci_windows_dns_winrm/tasks/main.yml

- name: Ensure AD DNS servers are set on all adapters
  ansible.windows.win_dns_client:
    adapter_names: '*'
    ipv4_addresses: "{{ sci_ad_dns_servers }}"
  register: dns_client_result

- name: Clear legacy SearchList baked into image
  ansible.windows.win_regedit:
    path: HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters
    name: SearchList
    state: absent

- name: Set global SearchList to AD DNS domain
  ansible.windows.win_regedit:
    path: HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters
    name: SearchList
    type: string
    data: "{{ sci_ad_dns_domain }}"

- name: Disable DNS devolution
  ansible.windows.win_regedit:
    path: HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters
    name: UseDomainNameDevolution
    type: dword
    data: 0

# Optional: also enforce via policy hive (DNS Client GPO equivalent)
- name: Set policy DNS SearchList (HKLM\Software\Policies\...\DNSClient)
  ansible.windows.win_regedit:
    path: HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient
    name: SearchList
    type: string
    data: "{{ sci_ad_dns_domain }}"

- name: Disable DNS devolution via policy
  ansible.windows.win_regedit:
    path: HKLM:\Software\Policies\Microsoft\Windows NT\DNSClient
    name: UseDomainNameDevolution
    type: dword
    data: 0

# --- WinRM HTTPS setup (optional) ---

- name: Configure WinRM HTTPS listener and firewall
  ansible.windows.win_shell: |
    $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME `
      -CertStoreLocation Cert:\LocalMachine\My

    winrm quickconfig -quiet
    winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null

    winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
      "@{Hostname=`"$env:COMPUTERNAME`";CertificateThumbprint=`"$($cert.Thumbprint)`"}"

    winrm set winrm/config/service '@{AllowUnencrypted="false"}'
    winrm set winrm/config/service/Auth '@{Basic="true";Kerberos="true";Negotiate="true"}'

    if (-not (Get-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' -ErrorAction SilentlyContinue)) {
      New-NetFirewallRule -DisplayName 'WINRM-HTTPS-In' `
        -Direction Inbound -Protocol TCP -LocalPort 5986 -Action Allow
    }
  args:
    executable: powershell.exe
  when: sci_enable_winrm | bool

# Optional debug to see effective settings

- name: Show effective DNS servers
  ansible.windows.win_shell: Get-DnsClientServerAddress | Format-Table -AutoSize
  register: sci_dns_servers_out

- debug:
    var: sci_dns_servers_out.stdout_lines

- name: Show effective SearchList
  ansible.windows.win_shell: |
    reg query HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters /v SearchList
  register: sci_searchlist_out

- debug:
    var: sci_searchlist_out.stdout_lines
```

This is idempotent: you can run it repeatedly and it will only change things when needed.

---

## 4Ô∏è‚É£ Example playbook using the role

Once WinRM is working to at least one test box:

```yaml
# fix-windows-dns-winrm.yml

- name: Fix DNS suffix and WinRM on SCI Windows servers
  hosts: windows
  gather_facts: no

  roles:
    - role: sci_windows_dns_winrm
      vars:
        sci_ad_dns_domain: "directory.sci-dev.scs.internal"
        sci_ad_dns_servers:
          - "10.20.30.40"
          - "10.20.30.41"
        sci_enable_winrm: true
```

Run it with:

```bash
ansible-playbook -i inventory.ini fix-windows-dns-winrm.yml
```

Later you can:

* Override vars per-group (`[sci-dev]`, `[sci-prod]`)
* Turn `sci_enable_winrm` off in environments where WinRM is managed differently.

---

## 5Ô∏è‚É£ Why having this as an Ansible role is a win

You already have:

* Cloudbase-Init / domain-join script for **initial** fix
* GPO for **post-join enforcement**

The Ansible role adds a **3rd layer of control + observability**:

### üîÅ Idempotent remediation

* You can run the role against hundreds of VMs; anything already correct is skipped.
* Anything drifted (wrong DNS, wrong suffix) gets pulled back into compliance.

### üåç Environment-aware

* The same role works for **dev, test, prod, multiple tenants**.
* You just change `sci_ad_dns_domain` and `sci_ad_dns_servers` with inventory/group vars.

### üîé Audit capability

* Run in `--check` mode or add ‚Äúassert‚Äù tasks to **report** which VMs are misconfigured.
* This is gold for ‚Äúshow me all SCI VMs not using AD DNS‚Äù type requests.

### üß± Single source of truth for the logic

Instead of:

* one version in Cloudbase-Init
* a slightly different one in a PowerShell script
* and a third one in someone‚Äôs notes

‚Ä¶you can standardize on the Ansible role as the canonical implementation, and have the PS / cloud-init versions mirror it.

### ü§ù Plays nicely with GPO

* GPO is still the *authoritative* enforcement layer after join.
* The role is perfect for:

  * pre-join cleanup in non-GPO environments
  * tenants where you don‚Äôt control AD
  * one-off fixes when someone bypassed the standard build

### üöÄ Future-proof for more automation

Once WinRM is enabled by this same role, you can easily bolt on:

* a **domain-join role**
* a **hardening role**
* app install roles (IIS, SQL, whatever)

‚Ä¶all using the same connection method.

---

If you want to go one step further, I can:

* Add a **domain-join task** into its own role (`sci_windows_domain_join`) that expects DNS to be correct (thanks to this role), and
* Give you a ‚Äúfull pipeline‚Äù playbook: `bootstrap ‚Üí join domain ‚Üí tag in AD / move OU`.





 ============================================================

Yes, you can absolutely:

1. Add a **domain-join role** on top of the DNS/WinRM role
2. Use **dynamic inventories** for your SAP SCI OpenStack environment
3. Automate a *lot* of this end-to-end (create VM ‚Üí fix DNS/WinRM ‚Üí join domain ‚Üí done)

I‚Äôll break it into:

* A. Domain-join role that assumes DNS is already fixed
* B. Dynamic inventory for SCI (OpenStack)
* C. How to tie it all together into a dynamic, automated flow

---

## A. Domain-join role (on top of the DNS/WinRM role)

Let‚Äôs add a second role: `sci_windows_domain_join`.

### Role structure

```text
roles/
  sci_windows_dns_winrm/
  sci_windows_domain_join/
    defaults/
      main.yml
    tasks/
      main.yml
```

### `roles/sci_windows_domain_join/defaults/main.yml`

```yaml
# AD domain you‚Äôre joining
sci_ad_domain: "directory.sci-dev.scs.internal"

# UPN or DOMAIN\User that has rights to join machines
sci_ad_join_user: "SCS\\ad-join-user"

# Store the password in Ansible Vault
sci_ad_join_password: "CHANGE_ME_IN_VAULT"

# Optional OU to pre-place the computer account
# Example: "OU=Servers,OU=SCI,DC=directory,DC=sci-dev,DC=scs,DC=internal"
sci_ad_target_ou: ""

# Whether to reboot after the join
sci_ad_reboot_after_join: true
```

### `roles/sci_windows_domain_join/tasks/main.yml`

```yaml
# roles/sci_windows_domain_join/tasks/main.yml

- name: Check if machine is already domain-joined
  ansible.windows.win_shell: |
    (Get-ComputerInfo).CsDomain
  register: sci_domain_info

- name: Show current domain membership
  debug:
    msg: "Current domain/workgroup: {{ sci_domain_info.stdout | trim }}"

- name: Skip join if already in target domain
  meta: end_play
  when: sci_domain_info.stdout is search(sci_ad_domain, ignorecase=True)

- name: Join machine to domain
  ansible.windows.win_domain_membership:
    dns_domain_name: "{{ sci_ad_domain }}"
    domain_admin_user: "{{ sci_ad_join_user }}"
    domain_admin_password: "{{ sci_ad_join_password }}"
    # Only set domain_ou if you actually want to override default placement
    domain_ou: "{{ sci_ad_target_ou | default(omit) }}"
    state: domain
  register: sci_domain_join_result

- debug:
    var: sci_domain_join_result

- name: Reboot after join if requested
  ansible.windows.win_reboot:
    msg: "Rebooting to complete domain join"
    pre_reboot_delay: 5
  when:
    - sci_ad_reboot_after_join | bool
    - sci_domain_join_result.changed | bool
```

### Combined playbook using both roles

```yaml
# sci-windows-bootstrap.yml

- name: Bootstrap SCI Windows VM (DNS/WinRM + Domain Join)
  hosts: windows
  gather_facts: no

  roles:
    - role: sci_windows_dns_winrm
      vars:
        sci_ad_dns_domain: "directory.sci-dev.scs.internal"
        sci_ad_dns_servers:
          - "10.20.30.40"
          - "10.20.30.41"
        sci_enable_winrm: true

    - role: sci_windows_domain_join
      vars:
        sci_ad_domain: "directory.sci-dev.scs.internal"
        sci_ad_join_user: "SCS\\ad-join-user"
        sci_ad_join_password: "{{ vault_ad_join_password }}"
        sci_ad_target_ou: "OU=SCI-Servers,DC=directory,DC=sci-dev,DC=scs,DC=internal"
        sci_ad_reboot_after_join: true
```

Then in `group_vars/windows.yml` you‚Äôd have:

```yaml
vault_ad_join_password: !vault |
  # ansible-vault encrypted blob
```

Run:

```bash
ansible-playbook -i openstack_dynamic.yml sci-windows-bootstrap.yml
```

---

## B. Dynamic inventory for SAP SCI (OpenStack)

Since SCI is OpenStack-based, you can use Ansible‚Äôs **OpenStack inventory plugin**.

### 1. Install the OpenStack collection

On your control machine:

```bash
ansible-galaxy collection install openstack.cloud
```

### 2. Create `openstack_clouds.yml` (clouds.yaml)

SCI usually gives you Keystone auth details. You put those in `~/.config/openstack/clouds.yaml` or a project file.

Example:

```yaml
clouds:
  sci:
    auth:
      auth_url: https://identity.sci.example.com/v3
      username: your-user
      password: your-password
      project_name: your-project
      user_domain_name: Default
      project_domain_name: Default
    region_name: eu-de-1
    interface: public
    identity_api_version: 3
```

(You‚Äôll map that to whatever SCI gives you.)

### 3. Ansible dynamic inventory file (e.g. `openstack_dynamic.yml`)

```yaml
plugin: openstack.cloud.openstack

cloud: sci        # must match the name in clouds.yaml

# Only include servers in a certain project/region
expand_hostvars: true
fail_on_errors: true

# Optional: filter to just Windows instances (if you tag them)
compose:
  ansible_host: public_v4  # or private_v4 if you use VPN

keyed_groups:
  # Group by image name
  - key: image.name
    prefix: os_image

  # Group by a server metadata key, e.g. "role"
  - key: metadata.role
    prefix: role

filters:
  status: "ACTIVE"
```

Then your inventory is just:

```bash
ansible-inventory -i openstack_dynamic.yml --graph
```

And your playbook can target specific groups like:

```yaml
- hosts: "role_windows & os_image_win-2019-fixed-v1"
  ...
```

**Bottom line:** as long as SCI exposes regular OpenStack APIs and you can get a `clouds.yaml` from them, you *can* do dynamic inventory.

---

## C. Automating end-to-end (dynamic, SCI-aware)

Here‚Äôs how all the pieces can work together dynamically:

### 1. Use Ansible to **create** VMs in SCI

With `openstack.cloud.server` module you can:

```yaml
- name: Create SCI Windows VM
  hosts: localhost
  gather_facts: no
  collections:
    - openstack.cloud

  vars:
    sci_image: "win-2019-fixed-v1"
    sci_flavor: "m1.medium"
    sci_network: "private-net"
    sci_keypair: "your-keypair"
    count: 1

  tasks:
    - name: Create server(s)
      openstack.cloud.server:
        cloud: sci
        state: present
        name: "win-sci-{{ item }}"
        image: "{{ sci_image }}"
        flavor: "{{ sci_flavor }}"
        key_name: "{{ sci_keypair }}"
        nics:
          - net-name: "{{ sci_network }}"
        auto_ip: yes         # allocate floating IP
        wait: yes
        timeout: 600
        meta:
          role: "windows"
      loop: "{{ range(1, count + 1) | list }}"
      register: created_servers

    - debug:
        var: created_servers
```

### 2. Use **dynamic inventory** to pick up those VMs by metadata

Because you tagged them with `meta: role=windows`, the dynamic inventory groups them under `role_windows`.

### 3. Run your Windows bootstrap + domain join roles against them

Second play:

```yaml
- name: Bootstrap all freshly created SCI Windows servers
  hosts: "role_windows"
  gather_facts: no

  roles:
    - sci_windows_dns_winrm
    - sci_windows_domain_join
```

You can even chain this in a single playbook with multiple plays:

* First play: `localhost` ‚Üí creates instances on SCI
* Second play: dynamic `windows` group ‚Üí configures them

That‚Äôs full **API-driven, dynamic, idempotent** deployment.

---

## D. Why this setup (dynamic inventory + roles) is such a win for you

### 1. **No hard-coded host lists**

You don‚Äôt maintain inventory files by hand:

* New VM appears in OpenStack ‚Üí it automatically appears in your Ansible inventory based on filters/tags.
* Delete VM ‚Üí it disappears from inventory.

### 2. **Environment-aware automation**

You can drive behavior based on:

* project / tenant
* image name (e.g. only run bootstrap on `win-2019-fixed-v1`)
* metadata tags (e.g. `role=domain-joined`, `role=dmz`, etc.)

Want to run the join only on dev?

```yaml
hosts: "role_windows & meta_env_dev"
```

### 3. **Repeatable pipeline**

You can go from:

> ‚ÄúI need ten new Windows servers in SCI, domain-joined, with correct DNS and managed by Ansible‚Ä¶‚Äù

to:

```bash
ansible-playbook create-and-bootstrap-sci-windows.yml
```

‚Ä¶and the system handles:

* Creating VMs via OpenStack API
* Waiting for them to become reachable
* Fixing DNS & suffix
* Enabling WinRM
* Joining the domain
* Rebooting
* Leaving them in a known-good state

### 4. **Easier to evolve**

When the image team finally blesses a new base image:

* You update one var: `sci_image: "win-2019-fixed-v2"`
* Everything else stays the same.

When AD DNS changes:

* You update `sci_ad_dns_servers` in one place (group_vars).
* Re-run the DNS/WinRM role ‚Üí every box is updated.

### 5. **You get centralized observability**

Because Ansible is declarative and logs what changed, you can answer questions like:

* ‚ÄúWhich SCI Windows servers are still using SAP DNS?‚Äù
* ‚ÄúWhich ones haven‚Äôt joined the domain yet?‚Äù
* ‚ÄúWhich ones failed bootstrap and why?‚Äù

---

If you want to go further, next step could be:

* A single **‚ÄúSCI Windows Platform‚Äù** repo with:

  * `roles/sci_windows_dns_winrm`
  * `roles/sci_windows_domain_join`
  * `roles/sci_windows_base_hardening` (later)
  * `inventories/openstack_dynamic.yml`
  * pipelines for dev/test/prod

I can help you stub out that repo layout and a `README.md` that explains to other engineers ‚Äúthis is how we bring up Windows in SCI, every time.‚Äù





  
 ============================================================
 ============================================================
 ============================================================
 ============================================================
 ============================================================
 ============================================================

 
