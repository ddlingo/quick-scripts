Certainly! Here’s a **brief, practical guide** for editing each Terraform file to target a new environment (e.g., staging, prod, a different OpenStack cloud, or a different project/customer):

---

### 1. `provider.tf`
**What it does:**  
Defines which OpenStack cloud and region to use.

**How to edit for new environment:**  
- **No need to edit this file** directly for new environments if you’re using variables (`os_cloud_name`, `os_region_name`).
- Instead, ensure your new environment’s `.tfvars` file has the correct values:
    ```hcl
    os_cloud_name  = "new-cloud"
    os_region_name = "new-region"
    ```

---

### 2. `variables.tf`
**What it does:**  
Declares all variables your configuration uses.

**How to edit for new environment:**  
- **Usually, do NOT edit this file** for new environments.
- Only update if you add/remove/change variables for all environments.

---

### 3. `workspace-tfvars/dev-sms-L-sci.tfvars`  
**(You will duplicate and rename this file, e.g., `prod-app-L-sci.tfvars`)**

**What it does:**  
Defines all variable values for a specific environment.

**How to edit for new environment:**  
- **Duplicate and rename the file** for each new environment.
- Edit values for:
    - `os_cloud_name`, `os_region_name` (new cloud/region)
    - `project_name`, `domain_id`, `image_name`, `flavor_name`, `keypair_name`
    - Any tags (`owner`, `environment`, etc.)
    - Network CIDRs, subnets, DNS, etc.
    - IAM values (group names, admin details)
- Example for prod:
    ```hcl
    os_cloud_name = "prod-cloud"
    os_region_name = "eu-west-2"
    project_name = "prod-app"
    environment = "prod"
    owner = "alice"
    # ...and so on
    ```

---

### 4. `network.tf`
**What it does:**  
Defines networks, subnets, routers, and ports.

**How to edit for new environment:**  
- **No need to edit the file itself** for a new environment if networks/subnets are parameterized.
- Just update the `.tfvars` file with new CIDRs, DNS, or network names as needed.

---

### 5. `security_groups.tf`
**What it does:**  
Defines security groups and rules.

**How to edit for new environment:**  
- **Usually no need to edit** unless you want different rules (e.g., more restrictive SSH in prod).
- To tighten/loosen rules, edit this file directly.

---

### 6. `compute.tf`
**What it does:**  
Defines servers, floating IPs, and their associations.

**How to edit for new environment:**  
- **No need to edit for new environments** if parameters like `image_name`, `flavor_name`, etc. are in your `.tfvars`.
- **Edit the file** if you want a different server count, naming, or network attachment logic in the new environment.

---

### 7. `keystone.tf`
**What it does:**  
Handles IAM/project/federation assignments.

**How to edit for new environment:**  
- **No need to edit** unless group/role logic changes.
- Use different group/role variable values in your new `.tfvars` file as needed.

---

### 8. `outputs.tf`
**What it does:**  
Prints resource IDs and info after apply.

**How to edit for new environment:**  
- **Rarely needs editing.**  
- Only change if you want to add/remove outputs.

---

## **Summary Table**

| File                | Do you edit for new env? | Typical change for new env                   |
|---------------------|:-----------------------:|----------------------------------------------|
| provider.tf         |           ❌            | Use new values in tfvars                     |
| variables.tf        |           ❌            | Only if global variable definitions change   |
| *.tfvars            |           ✅            | **Yes — always duplicate & edit this file**  |
| network.tf          |           ❌            | Use new values in tfvars                     |
| security_groups.tf  |      Optional           | Edit for rule/policy changes only            |
| compute.tf          |      Optional           | Edit for instance count/type changes         |
| keystone.tf         |      Optional           | Edit for IAM logic changes only              |
| outputs.tf          |           ❌            | Only for different outputs                   |

---

## **How to create a new environment:**
1. **Copy** your `.tfvars` file, rename it (e.g., `prod-app-L-sci.tfvars`).
2. **Edit the new file** for all environment-specific values.
3. **Run Terraform** with the new tfvars file:
   ```sh
   terraform plan -var-file=workspace-tfvars/prod-app-L-sci.tfvars
   terraform apply -var-file=workspace-tfvars/prod-app-L-sci.tfvars
   ```

---

**Let me know if you want a sample for a specific environment or more detailed examples for any file!**
Here’s the side-by-side you asked for—focused, no fluff.

# AWS IAM Orchestration ↔ SCI (OpenStack Keystone) Orchestration

| Topic                    | **AWS IAM (original)**                                               | **SCI / OpenStack Keystone (new)**                                                                        | Notes / Migration Tip                                                     |
| ------------------------ | -------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **Identity store**       | IAM (users, groups) in AWS                                           | Keystone (users, groups)                                                                                  | If you federate, most identities live in IdP (AD/Keycloak) not locally.   |
| **AuthN**                | Access keys, console creds; SSO via SAML/OIDC (AWS SSO/IAM IdP)      | Tokens from Keystone; SSO via SAML/OIDC to Keystone                                                       | Keep SSO; switch IdP trust from AWS to Keystone.                          |
| **Federation**           | IAM SAML/OIDC provider + role assumption                             | Keystone federation mapping (claims → Keystone groups)                                                    | Recreate mapping rules in Keystone; stop using IAM IdP.                   |
| **Principals**           | Users, Roles, Groups                                                 | Users, Roles, Groups                                                                                      | Same concepts; different APIs.                                            |
| **Permission unit**      | **Policies** (JSON) attached to roles/users/groups                   | **Policies** (policy.yaml) enforced per service; **roles** are labels                                     | In Keystone, roles are labels; service policies interpret them.           |
| **Role granularity**     | Fine-grained IAM JSON (Allow/Deny, resource ARNs)                    | Roles are additive; services gate actions via policy rules (no explicit deny)                             | Expect “union of roles” behavior; design least-priv via service policies. |
| **Scope**                | Account / resource-ARN scoped; cross-account via trust               | Project (tenant) / domain scoped                                                                          | Map AWS “accounts” → Keystone **projects** (or domains).                  |
| **Cross-X access**       | Cross-account **assume-role** trust                                  | Multi-project role assignment (user/group ↔ role ↔ project)                                               | No assume-role; you grant roles in each project.                          |
| **Resource-side policy** | Many AWS services support resource policies (S3 bucket policy, etc.) | Most OpenStack services use centralized policy.yaml; few resource-side ACLs                               | Manage at service policy + role level.                                    |
| **Infra state**          | Terraform aws\_iam\_\*                                               | Terraform **openstack\_**\* (for compute/network); Keystone RBAC often configured outside TF or via tools | Treat identity as platform config (Keystone), infra (nets/VMs) in TF.     |
| **Auditing**             | CloudTrail, IAM Access Analyzer                                      | Keystone + service logs, audit middleware                                                                 | Ensure logs retained centrally (ELK/SIEM).                                |

## What carries over vs changes

**Carries over**

* Groups ↔ roles mapping (via federation claims).
* Per-environment isolation (workspaces → projects).
* “Least privilege” mindset (but enforced differently).

**Changes**

* No explicit **Deny** in Keystone; permissions are **additive** across roles.
* No **assume-role**; instead, **assign roles per project** to users/groups.
* Fine-grained JSON policies → **service policy rules** (policy.yaml) + role names.

## Minimal migration checklist

1. **Federation**

   * Export AD/Keycloak group claims.
   * Create Keystone **mapping rules** (claims → Keystone groups).
   * Assign **roles** to those groups **per project**:

     ```
     openstack role add --group <grp> --project <proj> <role>
     ```

2. **Roles & Policies**

   * Pick standard roles (`admin`, `member`, `reader`) and add custom roles only if policy needs it.
   * Review each service’s **policy.yaml** (Nova/Neutron/Cinder) to ensure `member/reader/admin` do exactly what you expect.

3. **Project layout**

   * Map AWS accounts/workspaces → **Keystone projects** (and optional **domains** for higher-level separation).
   * Grant groups the right roles in each project (no assume-role hop).

4. **Terraform**

   * Remove `aws_iam_*`.
   * Keep Terraform for **network/compute/security groups** (OpenStack provider).
   * Manage Keystone federation & policy via platform automation (Ansible/OpenStack CLI) or a dedicated TF module if you decide to codify it.

If you want, I can draft the **Keystone federation mapping** (Keycloak/AD → Keystone groups) and the **role add** commands for your `SCI-scs-dev` project so you can paste-and-go.

To assign multiple roles to a group in a single OpenStack project using Terraform, you’ll want to:

1. Make your role variable a list of role names.
2. Use a `for_each` or a loop to look up and assign each role to the group.
3. Keep your group and project variable as usual.

Here’s a complete, practical example:

---

```hcl name=variables.tf
variable "federated_group_local_name" {
  type = string
}
variable "openstack_role_names" {
  type = list(string) # List of role names
}
variable "project_name" {
  type = string
}
variable "domain_id" {
  type = string
}
```

---

```hcl name=keystone.tf
# Lookup the group (federated from Keycloak/SCI)
data "openstack_identity_group_v3" "federated_group" {
  name      = var.federated_group_local_name
  domain_id = var.domain_id
}

# Lookup each role by name
data "openstack_identity_role_v3" "roles" {
  for_each = toset(var.openstack_role_names)
  name     = each.value
}

# Create the project
resource "openstack_identity_project_v3" "project" {
  name      = var.project_name
  domain_id = var.domain_id
}

# Assign each role to the group in the project
resource "openstack_identity_role_assignment_v3" "group_role_assignments" {
  for_each   = data.openstack_identity_role_v3.roles
  group_id   = data.openstack_identity_group_v3.federated_group.id
  project_id = openstack_identity_project_v3.project.id
  role_id    = each.value.id
}
```

---

```hcl name=workspace-tfvars/dev-multi-role.tfvars
federated_group_local_name = "SAP_Developers"
openstack_role_names       = ["member", "custom_project_admin", "reader"]
project_name               = "dev-sms"
domain_id                  = "default"
```

---

## How it works

- You provide a list of role names in `openstack_role_names` (in your `.tfvars`).
- Terraform will look up each role and assign it to the group in the specified project.
- All members of the group will receive the permissions of **all assigned roles** in the project.

---

## To use:

1. Add or update the variables in your `variables.tf` and `.tfvars`.
2. Use the updated `keystone.tf` code above.
3. Run:
   ```sh
   terraform init
   terraform plan -var-file=workspace-tfvars/dev-multi-role.tfvars
   terraform apply -var-file=workspace-tfvars/dev-multi-role.tfvars
   ```

---

**This is the standard pattern for assigning multiple roles to a group in OpenStack with Terraform.**  
Let me know if you want an example supporting multiple groups and multiple roles!
